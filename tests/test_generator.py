"""
Unit tests for the ACL generator module.

Tests cover:
- Structured input serialization to Mosquitto ACL syntax
- Invalid access type error handling
- Generated ACL file readability by parser
- Various formatting options
"""

import pytest
import tempfile
import os
from io import StringIO

from src.acl_visualizer.parser import ACLRule, parse_acl_file
from src.acl_visualizer.generator import (
    ACLGenerator, ACLGenerateError, generate_acl_file,
    validate_generation_input, merge_acl_rules, filter_rules_by_topic_pattern
)


class TestACLGenerator:
    """Test the ACLGenerator class."""
    
    def test_basic_generation(self):
        """Test basic ACL generation."""
        client_rules = {
            "device001": [
                ACLRule(client="device001", access="read", topic="sensors/temperature"),
                ACLRule(client="device001", access="write", topic="actuators/device001")
            ],
            "admin": [
                ACLRule(client="admin", access="readwrite", topic="#")
            ]
        }
        
        generator = ACLGenerator(sort_clients=True, include_comments=False)
        result = generator.generate_string(client_rules)
        
        # Check basic structure
        assert "user admin" in result
        assert "user device001" in result
        assert "topic #" in result  # readwrite is default, so no explicit access
        assert "topic read sensors/temperature" in result
        assert "topic write actuators/device001" in result
    
    def test_generation_with_comments(self):
        """Test ACL generation with header comments."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="read", topic="test/topic")
            ]
        }
        
        generator = ACLGenerator(include_comments=True)
        result = generator.generate_string(client_rules)
        
        assert "# Mosquitto ACL file" in result
        assert "# Generated by ACL Visualizer" in result
        assert "# Client: testuser" in result
    
    def test_generation_without_comments(self):
        """Test ACL generation without comments."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="read", topic="test/topic")
            ]
        }
        
        generator = ACLGenerator(include_comments=False)
        result = generator.generate_string(client_rules)
        
        assert "# Mosquitto ACL file" not in result
        assert "# Client:" not in result
        assert "user testuser" in result
        assert "topic read test/topic" in result
    
    def test_client_sorting(self):
        """Test client sorting functionality."""
        client_rules = {
            "zebra": [ACLRule(client="zebra", access="read", topic="z")],
            "alpha": [ACLRule(client="alpha", access="read", topic="a")],
            "beta": [ACLRule(client="beta", access="read", topic="b")]
        }
        
        generator = ACLGenerator(sort_clients=True, include_comments=False)
        result = generator.generate_string(client_rules)
        
        lines = result.strip().split('\n')
        user_lines = [line for line in lines if line.startswith('user ')]
        
        assert user_lines == ["user alpha", "user beta", "user zebra"]
    
    def test_no_client_sorting(self):
        """Test generation without client sorting."""
        client_rules = {
            "zebra": [ACLRule(client="zebra", access="read", topic="z")],
            "alpha": [ACLRule(client="alpha", access="read", topic="a")]
        }
        
        generator = ACLGenerator(sort_clients=False, include_comments=False)
        result = generator.generate_string(client_rules)
        
        # Order should match input order (dict insertion order)
        lines = result.strip().split('\n')
        user_lines = [line for line in lines if line.startswith('user ')]
        
        # Note: dict order depends on Python version, but zebra should come before alpha
        # since it was inserted first
        assert "user zebra" in user_lines
        assert "user alpha" in user_lines
    
    def test_access_filtering(self):
        """Test filtering rules by access type."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="read", topic="read/topic"),
                ACLRule(client="testuser", access="write", topic="write/topic"),
                ACLRule(client="testuser", access="readwrite", topic="readwrite/topic")
            ]
        }
        
        generator = ACLGenerator(include_comments=False)
        
        # Filter for read only
        result = generator.generate_string(client_rules, access_filter={'read'})
        assert "topic read read/topic" in result
        assert "write/topic" not in result
        assert "readwrite/topic" not in result
        
        # Filter for write only
        result = generator.generate_string(client_rules, access_filter={'write'})
        assert "topic write write/topic" in result
        assert "read/topic" not in result
        assert "readwrite/topic" not in result
    
    def test_readwrite_access_format(self):
        """Test that readwrite access is formatted correctly (no explicit access)."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="readwrite", topic="test/topic")
            ]
        }
        
        generator = ACLGenerator(include_comments=False)
        result = generator.generate_string(client_rules)
        
        # readwrite should not include explicit access type
        assert "topic test/topic" in result
        assert "topic readwrite test/topic" not in result
    
    def test_invalid_access_type_generation(self):
        """Test that invalid access types raise errors during generation."""
        # Create a rule with invalid access (bypassing ACLRule validation)
        client_rules = {
            "testuser": [
                type('MockRule', (), {
                    'client': 'testuser',
                    'access': 'invalid',
                    'topic': 'test/topic'
                })()
            ]
        }
        
        generator = ACLGenerator()
        with pytest.raises(ACLGenerateError, match="Invalid access type"):
            generator.generate_string(client_rules)
    
    def test_empty_client_rules(self):
        """Test generation with empty client rules."""
        generator = ACLGenerator(include_comments=False)
        result = generator.generate_string({})
        
        assert result.strip() == ""
    
    def test_client_with_no_rules_after_filtering(self):
        """Test that clients with no rules after filtering are skipped."""
        client_rules = {
            "readuser": [ACLRule(client="readuser", access="read", topic="read/topic")],
            "writeuser": [ACLRule(client="writeuser", access="write", topic="write/topic")]
        }
        
        generator = ACLGenerator(include_comments=False)
        result = generator.generate_string(client_rules, access_filter={'read'})
        
        assert "user readuser" in result
        assert "user writeuser" not in result
        assert "read/topic" in result
        assert "write/topic" not in result


class TestFileOperations:
    """Test file-based generation operations."""
    
    def test_generate_file_success(self):
        """Test successful file generation."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="read", topic="test/topic")
            ]
        }
        
        with tempfile.NamedTemporaryFile(mode='w', suffix='.acl', delete=False) as f:
            temp_path = f.name
        
        try:
            generate_acl_file(client_rules, temp_path, include_comments=False)
            
            # Verify file was created and has correct content
            with open(temp_path, 'r') as f:
                content = f.read()
            
            assert "user testuser" in content
            assert "topic read test/topic" in content
        finally:
            os.unlink(temp_path)
    
    def test_generate_file_permission_error(self):
        """Test file generation with permission errors."""
        client_rules = {
            "testuser": [ACLRule(client="testuser", access="read", topic="test")]
        }
        
        # Try to write to a read-only directory (if possible)
        invalid_path = "/root/readonly.acl"  # Typically not writable
        
        generator = ACLGenerator()
        with pytest.raises(ACLGenerateError, match="Failed to write ACL file"):
            generator.generate_file(client_rules, invalid_path)


class TestRoundTripCompatibility:
    """Test that generated ACL files can be parsed back correctly."""
    
    def test_roundtrip_parsing(self):
        """Test that generated ACL can be parsed back by parser."""
        original_rules = {
            "device001": [
                ACLRule(client="device001", access="read", topic="sensors/temperature/+"),
                ACLRule(client="device001", access="write", topic="actuators/device001/control")
            ],
            "device002": [
                ACLRule(client="device002", access="readwrite", topic="devices/device002/#")
            ],
            "admin": [
                ACLRule(client="admin", access="readwrite", topic="#")
            ]
        }
        
        # Generate ACL content
        generator = ACLGenerator(sort_clients=True, include_comments=True)
        acl_content = generator.generate_string(original_rules)
        
        # Parse it back
        parsed_rules = {}
        with tempfile.NamedTemporaryFile(mode='w', suffix='.acl', delete=False) as f:
            f.write(acl_content)
            temp_path = f.name
        
        try:
            parsed_rules = parse_acl_file(temp_path)
        finally:
            os.unlink(temp_path)
        
        # Compare original and parsed rules
        assert len(parsed_rules) == len(original_rules)
        
        for client_name in original_rules:
            assert client_name in parsed_rules
            
            original_topics = [(r.access, r.topic) for r in original_rules[client_name]]
            parsed_topics = [(r.access, r.topic) for r in parsed_rules[client_name]]
            
            assert set(original_topics) == set(parsed_topics)
    
    def test_roundtrip_with_special_characters(self):
        """Test roundtrip with special characters in topics and usernames."""
        original_rules = {
            "device-001_test": [
                ACLRule(client="device-001_test", access="read", topic="sensors/temp-01/data"),
                ACLRule(client="device-001_test", access="write", topic="actuators/device_001/cmd")
            ]
        }
        
        generator = ACLGenerator(include_comments=False)
        acl_content = generator.generate_string(original_rules)
        
        # Parse back using string parsing
        from src.acl_visualizer.parser import ACLParser
        parser = ACLParser()
        parsed_rules = parser.parse_string(acl_content)
        
        # Verify content matches
        assert "device-001_test" in parsed_rules
        original_topics = [(r.access, r.topic) for r in original_rules["device-001_test"]]
        parsed_topics = [(r.access, r.topic) for r in parsed_rules["device-001_test"]]
        assert set(original_topics) == set(parsed_topics)


class TestValidation:
    """Test input validation functions."""
    
    def test_validate_valid_input(self):
        """Test validation of valid input data."""
        client_rules = {
            "testuser": [
                ACLRule(client="testuser", access="read", topic="test/topic")
            ]
        }
        
        errors = validate_generation_input(client_rules)
        assert len(errors) == 0
    
    def test_validate_empty_input(self):
        """Test validation of empty input."""
        errors = validate_generation_input({})
        assert len(errors) == 1
        assert "No client rules provided" in errors[0]
    
    def test_validate_empty_client_name(self):
        """Test validation catches empty client names."""
        client_rules = {
            "": [ACLRule(client="", access="read", topic="test")]
        }
        
        errors = validate_generation_input(client_rules)
        assert any("Empty client name" in error for error in errors)
    
    def test_validate_non_list_rules(self):
        """Test validation catches non-list rule sets."""
        client_rules = {
            "testuser": "not a list"
        }
        
        errors = validate_generation_input(client_rules)
        assert any("rules must be a list" in error for error in errors)
    
    def test_validate_non_aclrule_objects(self):
        """Test validation catches non-ACLRule objects."""
        client_rules = {
            "testuser": ["not an ACLRule object"]
        }
        
        errors = validate_generation_input(client_rules)
        assert any("not an ACLRule object" in error for error in errors)
    
    def test_validate_empty_topic(self):
        """Test validation catches empty topics."""
        client_rules = {
            "testuser": [ACLRule(client="testuser", access="read", topic="")]
        }
        
        errors = validate_generation_input(client_rules)
        assert any("empty topic" in error for error in errors)
    
    def test_validate_invalid_access(self):
        """Test validation catches invalid access types."""
        # Create ACLRule with invalid access by bypassing normal constructor validation
        from dataclasses import fields
        rule = ACLRule.__new__(ACLRule)
        rule.client = "testuser"
        rule.topic = "test/topic"
        rule.access = "invalid"
        
        client_rules = {
            "testuser": [rule]
        }
        
        errors = validate_generation_input(client_rules)
        assert any("invalid access" in error for error in errors)


class TestUtilityFunctions:
    """Test utility functions for ACL manipulation."""
    
    def test_merge_acl_rules(self):
        """Test merging two sets of ACL rules."""
        rules1 = {
            "client1": [ACLRule(client="client1", access="read", topic="topic1")],
            "client2": [ACLRule(client="client2", access="write", topic="topic2")]
        }
        
        rules2 = {
            "client1": [ACLRule(client="client1", access="write", topic="topic3")],
            "client3": [ACLRule(client="client3", access="readwrite", topic="topic4")]
        }
        
        merged = merge_acl_rules(rules1, rules2)
        
        assert len(merged) == 3
        assert "client1" in merged
        assert "client2" in merged
        assert "client3" in merged
        
        # client1 should have rules from both sets
        assert len(merged["client1"]) == 2
        topics = [rule.topic for rule in merged["client1"]]
        assert "topic1" in topics
        assert "topic3" in topics
    
    def test_merge_duplicate_rules(self):
        """Test that merge avoids duplicate rules."""
        rules1 = {
            "client1": [ACLRule(client="client1", access="read", topic="same_topic")]
        }
        
        rules2 = {
            "client1": [ACLRule(client="client1", access="read", topic="same_topic")]
        }
        
        merged = merge_acl_rules(rules1, rules2)
        
        # Should not duplicate the same rule
        assert len(merged["client1"]) == 1
    
    def test_filter_rules_by_topic_pattern(self):
        """Test filtering rules by topic pattern."""
        client_rules = {
            "client1": [
                ACLRule(client="client1", access="read", topic="sensors/temperature/data"),
                ACLRule(client="client1", access="write", topic="actuators/pump/control"),
                ACLRule(client="client1", access="read", topic="sensors/humidity/data")
            ]
        }
        
        # Filter for sensor topics
        filtered = filter_rules_by_topic_pattern(client_rules, "sensors/*")
        
        assert "client1" in filtered
        topics = [rule.topic for rule in filtered["client1"]]
        assert "sensors/temperature/data" in topics
        assert "sensors/humidity/data" in topics
        assert "actuators/pump/control" not in topics
    
    def test_filter_with_wildcards(self):
        """Test filtering with MQTT wildcards."""
        client_rules = {
            "client1": [
                ACLRule(client="client1", access="read", topic="sensors/temp/+/data"),
                ACLRule(client="client1", access="read", topic="devices/+/status"),
                ACLRule(client="client1", access="read", topic="system/log")
            ]
        }
        
        # Filter using + wildcard
        filtered = filter_rules_by_topic_pattern(client_rules, "sensors/+")
        
        # Should match patterns that start with "sensors/"
        assert len(filtered["client1"]) >= 1


if __name__ == "__main__":
    pytest.main([__file__])