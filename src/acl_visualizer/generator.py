"""
Mosquitto ACL Generator Module

This module generates valid Mosquitto ACL files from structured ACL data.
Supports sorting, filtering, and custom formatting options.
"""

from typing import Dict, List, Optional, Set, TextIO
from datetime import datetime
import os
from .parser import ACLRule


class ACLGenerateError(Exception):
    """Raised when ACL generation fails."""
    pass


class ACLGenerator:
    """Generator for Mosquitto ACL files."""
    
    def __init__(self, sort_clients: bool = True, include_comments: bool = True):
        """
        Initialize the ACL generator.
        
        Args:
            sort_clients: Whether to sort clients alphabetically
            include_comments: Whether to include comment headers
        """
        self.sort_clients = sort_clients
        self.include_comments = include_comments
    
    def generate_file(self, client_rules: Dict[str, List[ACLRule]], 
                     output_path: str, access_filter: Optional[Set[str]] = None) -> None:
        """
        Generate an ACL file from structured data.
        
        Args:
            client_rules: Dictionary mapping client names to ACLRule lists
            output_path: Path where to write the ACL file
            access_filter: Optional set of access types to include ('read', 'write', 'readwrite')
            
        Raises:
            ACLGenerateError: If generation fails
        """
        try:
            with open(output_path, 'w', encoding='utf-8') as f:
                self.generate_stream(client_rules, f, access_filter)
        except (IOError, OSError) as e:
            raise ACLGenerateError(f"Failed to write ACL file {output_path}: {e}")
    
    def generate_string(self, client_rules: Dict[str, List[ACLRule]], 
                       access_filter: Optional[Set[str]] = None) -> str:
        """
        Generate ACL content as a string.
        
        Args:
            client_rules: Dictionary mapping client names to ACLRule lists
            access_filter: Optional set of access types to include
            
        Returns:
            ACL content as string
        """
        from io import StringIO
        output = StringIO()
        self.generate_stream(client_rules, output, access_filter)
        return output.getvalue()
    
    def generate_stream(self, client_rules: Dict[str, List[ACLRule]], 
                       stream: TextIO, access_filter: Optional[Set[str]] = None) -> None:
        """
        Generate ACL content to a text stream.
        
        Args:
            client_rules: Dictionary mapping client names to ACLRule lists
            stream: Text stream to write to
            access_filter: Optional set of access types to include
            
        Raises:
            ACLGenerateError: If generation fails
        """
        try:
            # Write header comment
            if self.include_comments:
                self._write_header(stream)
            
            # Get clients in order
            clients = sorted(client_rules.keys()) if self.sort_clients else list(client_rules.keys())
            
            # Write ACL rules for each client
            for i, client in enumerate(clients):
                rules = client_rules[client]
                
                # Filter rules by access type if specified
                if access_filter:
                    rules = [rule for rule in rules if rule.access in access_filter]
                
                # Skip clients with no rules after filtering
                if not rules:
                    continue
                
                # Add spacing between clients (except before first)
                if i > 0:
                    stream.write('\n')
                
                # Write client header
                if self.include_comments and len(rules) > 0:
                    stream.write(f'# Client: {client} ({len(rules)} rules)\n')
                
                # Write user declaration
                stream.write(f'user {client}\n')
                
                # Write topic rules
                for rule in rules:
                    self._write_topic_rule(stream, rule)
                    
        except Exception as e:
            raise ACLGenerateError(f"Failed to generate ACL content: {e}")
    
    def _write_header(self, stream: TextIO) -> None:
        """Write a header comment to the stream."""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        stream.write(f'# Mosquitto ACL file\n')
        stream.write(f'# Generated by ACL Visualizer on {timestamp}\n')
        stream.write(f'# \n')
        stream.write(f'# Format:\n')
        stream.write(f'# user <username>\n')
        stream.write(f'# topic [read|write|readwrite] <topic>\n')
        stream.write(f'# \n')
        stream.write(f'# Wildcards:\n')
        stream.write(f'#   + = single level wildcard\n')
        stream.write(f'#   # = multi level wildcard\n')
        stream.write('\n')
    
    def _write_topic_rule(self, stream: TextIO, rule: ACLRule) -> None:
        """
        Write a single topic rule to the stream.
        
        Args:
            stream: Text stream to write to
            rule: ACL rule to write
        """
        # Validate access type
        valid_access = {'read', 'write', 'readwrite'}
        if rule.access not in valid_access:
            raise ACLGenerateError(f"Invalid access type: {rule.access}")
        
        # Write topic line with appropriate format
        if rule.access == 'readwrite':
            # Default access, no need to specify
            stream.write(f'topic {rule.topic}\n')
        else:
            # Specify access type
            stream.write(f'topic {rule.access} {rule.topic}\n')


def generate_acl_file(client_rules: Dict[str, List[ACLRule]], 
                     output_path: str, **kwargs) -> None:
    """
    Convenience function to generate an ACL file.
    
    Args:
        client_rules: Dictionary mapping client names to ACLRule lists
        output_path: Path where to write the ACL file
        **kwargs: Additional arguments passed to ACLGenerator
    """
    generator = ACLGenerator(**kwargs)
    generator.generate_file(client_rules, output_path)


def validate_generation_input(client_rules: Dict[str, List[ACLRule]]) -> List[str]:
    """
    Validate input data before generation.
    
    Args:
        client_rules: Dictionary mapping client names to ACLRule lists
        
    Returns:
        List of validation errors
    """
    errors = []
    
    if not client_rules:
        errors.append("No client rules provided")
        return errors
    
    for client, rules in client_rules.items():
        if not client or not client.strip():
            errors.append("Empty client name found")
            continue
            
        if not isinstance(rules, list):
            errors.append(f"Client '{client}' rules must be a list")
            continue
            
        for i, rule in enumerate(rules):
            if not isinstance(rule, ACLRule):
                errors.append(f"Client '{client}' rule {i} is not an ACLRule object")
                continue
                
            # Validate rule fields
            if not rule.topic or not rule.topic.strip():
                errors.append(f"Client '{client}' rule {i} has empty topic")
                
            if rule.access not in {'read', 'write', 'readwrite'}:
                errors.append(f"Client '{client}' rule {i} has invalid access: {rule.access}")
    
    return errors


def merge_acl_rules(rules1: Dict[str, List[ACLRule]], 
                   rules2: Dict[str, List[ACLRule]]) -> Dict[str, List[ACLRule]]:
    """
    Merge two sets of ACL rules.
    
    Args:
        rules1: First set of ACL rules
        rules2: Second set of ACL rules
        
    Returns:
        Merged ACL rules
    """
    merged = rules1.copy()
    
    for client, rules in rules2.items():
        if client in merged:
            # Combine rules, avoiding duplicates
            existing_rules = {(r.access, r.topic) for r in merged[client]}
            new_rules = [r for r in rules if (r.access, r.topic) not in existing_rules]
            merged[client].extend(new_rules)
        else:
            merged[client] = rules.copy()
    
    return merged


def filter_rules_by_topic_pattern(client_rules: Dict[str, List[ACLRule]], 
                                 pattern: str) -> Dict[str, List[ACLRule]]:
    """
    Filter ACL rules by topic pattern.
    
    Args:
        client_rules: Dictionary mapping client names to ACLRule lists
        pattern: Topic pattern to match (supports wildcards)
        
    Returns:
        Filtered ACL rules
    """
    import fnmatch
    
    filtered = {}
    
    for client, rules in client_rules.items():
        matching_rules = []
        for rule in rules:
            # Convert MQTT wildcards to fnmatch patterns
            mqtt_pattern = pattern.replace('+', '*').replace('#', '**')
            if fnmatch.fnmatch(rule.topic, mqtt_pattern):
                matching_rules.append(rule)
        
        if matching_rules:
            filtered[client] = matching_rules
    
    return filtered


if __name__ == "__main__":
    import sys
    from .parser import parse_acl_file
    
    if len(sys.argv) < 3:
        print("Usage: python generator.py <input_acl_file> <output_acl_file> [access_filter]")
        print("  access_filter: comma-separated list of access types (read,write,readwrite)")
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    access_filter = None
    
    if len(sys.argv) > 3:
        access_filter = set(sys.argv[3].split(','))
    
    try:
        # Parse input file
        print(f"Parsing {input_file}...")
        rules = parse_acl_file(input_file)
        
        # Validate input
        errors = validate_generation_input(rules)
        if errors:
            print("Validation errors:")
            for error in errors:
                print(f"  ❌ {error}")
            sys.exit(1)
        
        # Generate output file
        print(f"Generating {output_file}...")
        generate_acl_file(rules, output_file, access_filter=access_filter)
        
        print(f"✅ Successfully generated ACL file: {output_file}")
        
        # Show summary
        total_rules = sum(len(client_rules) for client_rules in rules.values())
        print(f"   Clients: {len(rules)}")
        print(f"   Total rules: {total_rules}")
        if access_filter:
            print(f"   Access filter: {', '.join(access_filter)}")
            
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)